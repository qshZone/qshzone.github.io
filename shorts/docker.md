---
layout: page
title: Docker справочник
---

Полезные ссылки
- [Docker документация](https://docs.docker.com/)
- [Курс для Начинающих](https://youtu.be/_uZQtRyF6Eg) - трёх часовое видео, от базы, до составления `Dockerfile` и использование `docker-compose.yml`

Компоненты
- `Client` (клиент) - 
- `Daemon` (служба) - 
- `Host` (хост) - 
- `Image` (образ) - readonly образ приложения
- `Container` (контейнер) - работающее приложение на основе образа
- `Volume` (том) - файл или каталог, который хранится вне контейнера и подключается к нему	
- `Dockerfile` - файл описания образа
- Cлой - выполнение каждой команды в Dockerfile
- `docker-compose.yml - файл декларативного описания compose, в отличие от императивного подхода, когда выполняешь действия команда за командой
- `Repository` (репозиторий) - хранилище образов, например [Hub](https://hub.docker.com)
- `Registry` (реестр)


## Общие команды

Установка Docker на Linux `curl -sSL https://get.docker.com/ | sh`, `sudo apt install docker`


## Основные команды

Формат вызова команды `docker <command>`
- `build` - сборка образа по файлу `Dockerfile`  
Пример: `docker build . -t some-app`
- `images` - список доступных образов в репозитории
- `search <query>` - поиск в Docker Hub
- `pull <image name>` - загрузить образ из репозитория
- `push <image name>` - загрузить образ в репозиторий
- `run` - запуск контейнера, с параметром  
--rm - удаляет контейнер после завершения работы  
-it - интерактивно можно видеть весь вывод на консоль  
-p - переадресация портов в порядке на какой-откуда, пример `8080:80`, где `80` порт является внутренним портом контейнера  
-d - запускает в фоновом режиме контейнер с возвращением в командную строку  
-v - подключение тома в порядке на какой-откуда, пример `-v "/home/foo/app:/data"` или `-v ${PWD}:/data`, где `${PWD}` - это переменная, указывающая на текущую директорию, а папка `data` является папкой внутри контейнера  
--name - имя образа, указывается самым последним, если не указать, то генерируется автоматически  
- `ps` - список запущенных контейнеров  
-a - список с уже запускавшимися контейнерами
- `-e` - указание переменной окружения  
Пример: `-e TZ=Europe/Moscow`
- `exec` - выполнение команды внутри контейнера  
-it - переход на командную строку внутри контейнера, например, `exec -it <id> /bin/bash`, а для выхода из bash используется `exit`
- `start/stop <container name>`
- `rmi <image id>` - удаление образа
- `rm <container id or name>` - удаление контейнера по идентификатору или имени
- `history` - история образа
- `logs <name>` - логи контейнера, то что пишется в консоль
- `inspect <container name>` - получение информации по контейнеру: ip, 

Полезные команды
- `docker run --rm -it -p 8080:80 lps-app` - запуск контейнера с приложением, которое будет доступно на порту 8080 и контейнер будет удалён после остановки приложения по `Ctrl+C`
- `docker run -v ${PWD}:/usr/share/nginx/html nginx` - запуск контейнера с nginx и указание внешней папки с index.html
- `docker container prune` - очищает список контейнеров, которые не запущены
- `docker rm $(docker ps -qa)` - передача id всех контейнеров для удаления
- `docker build . -t some-app --build-arg <varname>=<value>` - построить образ с указанием переменных
- `docker exec -it <id> /bin/bash` или `exec -it <id> sh` - запуск интерактивно в оболочке, чтобы работать внутри контейнера


## Docker volume

- `docker volume ls`
- `docker volume create web` - создание тома
- `docker run ... -v web:/usr/src/app web-hello` - указание тома при методе run



## Dockerfile - сборка образа

Файл Dockerfile служит для описания шагов для формирования образа, который получается после билда файла.

При выполнении каждой команды создаётся новый слой, все эти слои могут выполняться параллельно.

Команды `Dockerfile`
- `EXPOSE`
- `ENV` - указание переменной окружения  
Пример: `ENV TZ Europe/Moscow`
- `FROM` - используемый образ, `latest` - последняя версия, `alpine` - минимальная по объёму версия  
Пример: `FROM python:alpine`
- `RUN` - запуск по командной строке  
Примеры: `mkdir -p /usr/src/app/`, `dotnet build "App.csproj" -c Release -o /app/build`, `RUN pip install mongo`
- `WORKDIR` - устанавливает рабочий каталог, в котором будут выполняться команды, при необходимости создаётся
- `COPY` - копирование файлов
Пример: `COPY . .` - из текущей папки выполнения DOckerfile в рабочую папку контейнера
- `CMD` - что нужно сделать, когда контейнер будет запущен, запускается через оболочку shell  
Пример: `CMD ["python, "app.py"]`
- `ENTRYPOINT` - выполняется без shell оболочки  
Пример: `ENTRYPOINT ["python, "app.py"]`


## Compose

- Все необходимые контейнеры запускаются одной командой
- Автоматическое создание контейнеров
- Создание изолированной сети для взаимодействия контейнеров
- Взаимодействие между контейнерами может быть через имена сервисов

Команды
- `docker-compose up` - запустить контейнеры  
-d - выполнение в фоновом режиме
--build - заново создать образы
- `docker-compose down` - остановить контейнеры и удалить

``` yaml
version: '3'

services:
  app:
    build: ./app
  mongo:
    image: mongo

```

Здесь
- Сначала будет создан образ для `app` и потом будет запущен контейнер для него, а потом будет запущен контейнер для `mongo`
- Оба контейнера будут находиться в единой сети и к ним можно обращаться по именам сервисов `app` и `mongo`, например, в строке подключения
- В некоторых случаях важен порядок выполнения сервисов, нужно учитывать создающийся кэш
- `build` - путь пишется относительно `yml` файла, либо указывается абсолютный


## Разное

- Где хранятся файлы образов на диске?
- Передача параметров в образ/в контейнер

